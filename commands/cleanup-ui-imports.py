#!/usr/bin/env python3
import os
import re
import argparse
import shutil
from collections import defaultdict
from pathlib import Path

# --- Configuration ---
NEXT_CONFIG_FILES = ["next.config.js", "next.config.ts", "next.config.mjs"]
UI_COMPONENTS_REL_PATH = Path("src/shared/components/ui")
BARREL_FILE_NAME = "index.ts"
DEFAULT_UI_IMPORT_ALIAS = "ui"

# --- Colorama for colored output ---
try:
    import colorama
    colorama.init(autoreset=True)
    GREEN = colorama.Fore.GREEN
    YELLOW = colorama.Fore.YELLOW
    RED = colorama.Fore.RED
    CYAN = colorama.Fore.CYAN
    MAGENTA = colorama.Fore.MAGENTA
    RESET = colorama.Style.RESET_ALL
except ImportError:
    GREEN = YELLOW = RED = CYAN = MAGENTA = RESET = ""

# --- Helper Functions ---

def find_project_root(start_path="."):
    current_path = Path(start_path).resolve()
    print(f"{CYAN}Attempting to find project root starting from: {MAGENTA}{current_path}{RESET}")
    while True:
        for config_file in NEXT_CONFIG_FILES:
            if (current_path / config_file).is_file():
                print(f"{GREEN}Found project root at: {MAGENTA}{current_path}{RESET}")
                return current_path
        parent_path = current_path.parent
        if parent_path == current_path:
            print(f"{RED}Error: Could not find project root ({'/'.join(NEXT_CONFIG_FILES)} not found).{RESET}")
            print(f"{YELLOW}Please ensure you are running the script from within your project or use the --root option.{RESET}")
            return None
        current_path = parent_path

def find_tsx_files(target_path: Path):
    print(f"{CYAN}Searching for .tsx files in: {MAGENTA}{target_path.resolve()}{RESET}")
    tsx_files = list(target_path.rglob("*.tsx"))
    if tsx_files:
        print(f"{GREEN}Found {len(tsx_files)} .tsx files to analyze.{RESET}")
    else:
        print(f"{YELLOW}No .tsx files found in {MAGENTA}{target_path.resolve()}{RESET}.")
    return tsx_files

def create_barrel_file(project_root: Path, dry_run=False):
    ui_dir_abs_path = (project_root / UI_COMPONENTS_REL_PATH).resolve()
    barrel_file_abs_path = (ui_dir_abs_path / BARREL_FILE_NAME).resolve()

    print(f"{CYAN}Checking UI components directory: {MAGENTA}{ui_dir_abs_path}{RESET}")
    if not ui_dir_abs_path.exists() or not ui_dir_abs_path.is_dir():
        print(f"{YELLOW}UI components directory not found: {MAGENTA}{ui_dir_abs_path}{RESET}")
        print(f"{YELLOW}Skipping barrel file creation. Please ensure the path '{UI_COMPONENTS_REL_PATH}' is correct.{RESET}")
        return False, barrel_file_abs_path

    print(f"{CYAN}Scanning UI components in: {MAGENTA}{ui_dir_abs_path}{RESET} to create barrel file '{BARREL_FILE_NAME}'")
    component_files = [
        f for f in ui_dir_abs_path.iterdir()
        if f.is_file() and (f.name.endswith(".ts") or f.name.endswith(".tsx")) and f.name != BARREL_FILE_NAME
    ]

    if not component_files:
        print(f"{YELLOW}No component files (ending in .ts or .tsx, excluding {BARREL_FILE_NAME}) found in {MAGENTA}{ui_dir_abs_path}{RESET} to export.")
        return False, barrel_file_abs_path

    exports = []
    print(f"{CYAN}The following components will be exported in '{MAGENTA}{barrel_file_abs_path}{RESET}':")
    for comp_file in sorted(component_files):
        module_name = comp_file.stem
        exports.append(f"export * from './{module_name}';")
        print(f"  {GREEN}export * from './{module_name}';{RESET} (from {comp_file.name})")

    barrel_content = "// Auto-generated by script\n" + "\n".join(exports) + "\n"

    if dry_run:
        print(f"{YELLOW}[DRY RUN]{RESET} Would create/update barrel file at: {MAGENTA}{barrel_file_abs_path}{RESET}")
        print(f"{YELLOW}[DRY RUN]{RESET} Barrel file content would be:\n{CYAN}{barrel_content}{RESET}")
        return True, barrel_file_abs_path

    try:
        print(f"{CYAN}Writing barrel file to: {MAGENTA}{barrel_file_abs_path}{RESET}")
        with open(barrel_file_abs_path, "w", encoding="utf-8") as f:
            f.write(barrel_content)
        print(f"{GREEN}Successfully created/updated barrel file: {MAGENTA}{barrel_file_abs_path}{RESET}")
        return True, barrel_file_abs_path
    except IOError as e:
        print(f"{RED}Error writing barrel file {MAGENTA}{barrel_file_abs_path}{RESET}: {e}")
        return False, barrel_file_abs_path

def get_backup_file_path(file_path: Path):
    return file_path.with_suffix(file_path.suffix + ".bak")

def backup_file(file_path: Path, dry_run=False): # dry_run is not strictly needed here, as it's checked before calling
    backup_path = get_backup_file_path(file_path)
    # No dry_run check here, assume it's handled by caller
    try:
        shutil.copy2(file_path, backup_path)
        print(f"  {CYAN}Backed up {MAGENTA}{file_path.resolve()}{RESET} to {MAGENTA}{backup_path.resolve()}{RESET}")
        return True
    except Exception as e:
        print(f"  {RED}Error backing up {MAGENTA}{file_path.resolve()}{RESET}: {e}")
        return False

def revert_file(file_path: Path, dry_run=False):
    backup_path = get_backup_file_path(file_path).resolve()
    resolved_file_path = file_path.resolve()
    if backup_path.exists():
        if not dry_run:
            try:
                shutil.move(str(backup_path), str(resolved_file_path))
                print(f"  {GREEN}Reverted {MAGENTA}{resolved_file_path}{RESET} from {MAGENTA}{backup_path}{RESET}")
                return True
            except Exception as e:
                print(f"  {RED}Error reverting {MAGENTA}{resolved_file_path}{RESET}: {e}")
                return False
        else:
            print(f"  {YELLOW}[DRY RUN]{RESET} Would revert {MAGENTA}{resolved_file_path}{RESET} from {MAGENTA}{backup_path}{RESET}")
            return True
    else:
        print(f"  {YELLOW}No backup file found for {MAGENTA}{resolved_file_path}{RESET} at {MAGENTA}{backup_path}{RESET}")
        return False

def update_import_statements(
    tsx_file_path: Path,
    project_root_path: Path,
    current_ui_import_alias: str,
    barrel_file_was_managed: bool,
    dry_run=False
):
    resolved_tsx_file_path = tsx_file_path.resolve()
    if not barrel_file_was_managed:
        print(f"{YELLOW}Note for {MAGENTA}{resolved_tsx_file_path}{RESET}: Barrel file management was skipped or incomplete. Assuming '{current_ui_import_alias}' points to a valid UI barrel if changes are made.{RESET}")

    ui_import_regex_str = r"import\s+(?:type\s+)?\{([^}]+)\}\s+from\s+(['\"])((?:[^'\"]*\/)?" + re.escape(UI_COMPONENTS_REL_PATH.name) + r"\/[^'\"]+)\2;?"
    ui_import_regex = re.compile(ui_import_regex_str)
    other_import_regex = re.compile(r"import\s+.*;") # General import regex to find other imports

    try:
        with open(resolved_tsx_file_path, "r", encoding="utf-8") as f:
            original_content = f.read()
    except Exception as e:
        print(f"  {RED}Error reading file {MAGENTA}{resolved_tsx_file_path}{RESET}: {e}")
        return False

    lines = original_content.splitlines()

    candidate_ui_import_details = [] # List of dicts: {'line_content': str, 'components': list, 'line_num': int}
    other_imports_to_keep = []       # Imports that are not candidates for consolidation
    code_lines_to_keep = []          # Non-import lines

    for line_num, line_content in enumerate(lines):
        is_candidate_ui_import = False
        match = ui_import_regex.search(line_content)
        if match:
            components_str = match.group(1).strip()
            # path_str = match.group(3) # Full path from the import statement
            components = [c.strip() for c in components_str.split(',') if c.strip()]
            if components:
                # This is a UI import matching our specific pattern (e.g., from '@/shared/components/ui/...')
                print(f"  {CYAN}In {MAGENTA}{resolved_tsx_file_path}{RESET} (line {line_num + 1}), found potential UI import: {GREEN}{line_content.strip()}{RESET}")
                candidate_ui_import_details.append({
                    'line_content': line_content,
                    'components': components,
                    'line_num': line_num
                })
                is_candidate_ui_import = True

        if not is_candidate_ui_import:
            # This line is NOT a UI import we plan to consolidate OR it didn't match the UI import regex
            if other_import_regex.search(line_content) and "from" in line_content:
                other_imports_to_keep.append(line_content)
            else:
                code_lines_to_keep.append(line_content)

    # Decision time: only consolidate if more than 1 specific UI import line was found
    if len(candidate_ui_import_details) > 1:
        print(f"  {CYAN}Found {len(candidate_ui_import_details)} distinct UI imports from specific UI paths in {MAGENTA}{resolved_tsx_file_path}{RESET}. Consolidating...{RESET}")

        all_ui_components_to_consolidate = set()
        for detail in candidate_ui_import_details:
            all_ui_components_to_consolidate.update(detail['components'])
            # Verbose logging of components being added from each line can be here if needed

        sorted_components = sorted(list(all_ui_components_to_consolidate))
        consolidated_ui_import_string = f"import {{ {', '.join(sorted_components)} }} from '{current_ui_import_alias}';"
        print(f"  {GREEN}Consolidated UI import for {MAGENTA}{resolved_tsx_file_path}{RESET}: {CYAN}{consolidated_ui_import_string}{RESET}")

        # Reconstruct file content: other imports, then the new consolidated UI import, then code lines
        updated_content_lines = other_imports_to_keep + [consolidated_ui_import_string] + code_lines_to_keep
        # Ensure a single trailing newline for consistent git diffs
        updated_content = "\n".join(updated_content_lines).strip() + "\n"

        # Check if the content actually changed
        if updated_content.strip() == original_content.strip():
            print(f"  {YELLOW}No effective change in content for {MAGENTA}{resolved_tsx_file_path}{RESET} after attempting consolidation (already organized or no net change).")
            return False # No actual modification

        # If we are here, content has changed.
        if dry_run:
            print(f"  {YELLOW}[DRY RUN]{RESET} Would modify {MAGENTA}{resolved_tsx_file_path}{RESET}.")
            # For detailed dry run of content change, you can print excerpts:
            # print(f"{YELLOW}--- OLD CONTENT (excerpt for {resolved_tsx_file_path}) ---{RESET}\n{original_content[:300]}...\n")
            # print(f"{YELLOW}--- NEW CONTENT (excerpt for {resolved_tsx_file_path}) ---{RESET}\n{updated_content[:300]}...\n")
            return True # Signify that a change would be made

        # Actual modification: backup first
        if not backup_file(resolved_tsx_file_path): # Pass resolved_tsx_file_path
            print(f"  {RED}Skipping modification of {MAGENTA}{resolved_tsx_file_path}{RESET} due to backup failure.")
            return False

        try:
            with open(resolved_tsx_file_path, "w", encoding="utf-8") as f:
                f.write(updated_content)
            print(f"  {GREEN}Successfully updated imports in: {MAGENTA}{resolved_tsx_file_path}{RESET}")
            return True # Actual modification happened
        except IOError as e:
            print(f"  {RED}Error writing updated file {MAGENTA}{resolved_tsx_file_path}{RESET}: {e}")
            # Attempt to restore from backup if write fails
            if get_backup_file_path(resolved_tsx_file_path).exists():
                 print(f"  {YELLOW}Attempting to restore {MAGENTA}{resolved_tsx_file_path}{RESET} from backup due to write error...{RESET}")
                 revert_file(resolved_tsx_file_path, dry_run=True) # Log revert attempt, don't actually revert in this state
            return False
    else:
        # 0 or 1 candidate UI imports, so no changes related to UI consolidation.
        num_found = len(candidate_ui_import_details)
        reason = "No specific UI imports found matching the pattern." if num_found == 0 else "Only 1 specific UI import found matching the pattern."
        print(f"  {CYAN}In {MAGENTA}{resolved_tsx_file_path}{RESET}: {reason} No consolidation performed (requires >1).{RESET}")
        return False


def process_files(project_root: Path, target_arg: str, dry_run=False, revert_mode=False, current_ui_alias: str = "ui"):
    if not project_root:
        return

    barrel_file_created_successfully = False
    barrel_file_path_actual = (project_root / UI_COMPONENTS_REL_PATH / BARREL_FILE_NAME).resolve()
    barrel_management_attempted = False

    if revert_mode:
        print(f"{YELLOW}--- Starting Revert Mode ---{RESET}")
    else:
        print(f"{CYAN}--- Starting Import Organization (alias: '{current_ui_alias}') ---{RESET}")
        barrel_management_attempted = True
        success, path = create_barrel_file(project_root, dry_run)
        barrel_file_created_successfully = success
        barrel_file_path_actual = path.resolve() # Ensure it's resolved

    process_path_base = project_root
    if target_arg:
        target_path_obj = Path(target_arg)
        if not target_path_obj.is_absolute():
            process_path_base = (project_root / target_path_obj).resolve()
        else:
            process_path_base = target_path_obj.resolve()

        if not process_path_base.exists():
            print(f"{RED}Error: Target path '{MAGENTA}{process_path_base}{RESET}' does not exist.")
            return
        print(f"{CYAN}Targeting specific path: {MAGENTA}{process_path_base}{RESET}")
    else:
        print(f"{CYAN}Processing all .tsx files in project root: {MAGENTA}{project_root.resolve()}{RESET}")

    files_to_process = []
    if process_path_base.is_file() and process_path_base.name.endswith(".tsx"):
        files_to_process = [process_path_base]
    elif process_path_base.is_dir():
        files_to_process = find_tsx_files(process_path_base)
    else:
        print(f"{RED}Error: Target '{MAGENTA}{process_path_base}{RESET}' is not a valid .tsx file or directory.")
        return

    if not files_to_process:
        print(f"{YELLOW}No .tsx files to process in {MAGENTA}{process_path_base.resolve()}{RESET}.")
        return

    modified_count = 0
    reverted_count = 0

    for tsx_file in files_to_process:
        resolved_tsx_file = tsx_file.resolve() # Use resolved path consistently
        if resolved_tsx_file == barrel_file_path_actual and not revert_mode:
            print(f"  {CYAN}Skipping processing of barrel file itself: {MAGENTA}{resolved_tsx_file}{RESET}")
            continue
        if resolved_tsx_file.name.endswith(".bak"):
            print(f"  {CYAN}Skipping backup file: {MAGENTA}{resolved_tsx_file}{RESET}")
            continue

        if revert_mode:
            if revert_file(resolved_tsx_file, dry_run):
                reverted_count +=1
        else:
            if update_import_statements(
                resolved_tsx_file,
                project_root,
                current_ui_alias,
                barrel_management_attempted,
                dry_run
            ):
                modified_count += 1

    # Summary
    if revert_mode:
        print(f"\n{GREEN if reverted_count > 0 else YELLOW}--- Revert Summary ---{RESET}")
        if dry_run:
            print(f"{YELLOW}[DRY RUN] Would have attempted to revert {reverted_count} file(s).{RESET}")
        else:
            print(f"{GREEN}{reverted_count} file(s) processed for reverting.{RESET}")
    else:
        print(f"\n{GREEN if modified_count > 0 or (barrel_management_attempted and barrel_file_created_successfully) else YELLOW}--- Processing Summary ---{RESET}")
        if dry_run:
            print(f"{YELLOW}[DRY RUN] Preview of changes complete.{RESET}")
            if barrel_management_attempted:
                status_msg = "would be created/updated" if barrel_file_created_successfully else "creation/update would be attempted"
                print(f"{YELLOW}[DRY RUN] Barrel file '{MAGENTA}{barrel_file_path_actual}{RESET}' {status_msg}.{RESET}")
            print(f"{YELLOW}[DRY RUN] {modified_count} .tsx file(s) would be modified.{RESET}")
        else:
            if barrel_management_attempted:
                status_msg = "created/updated successfully" if barrel_file_created_successfully else "management attempted (check logs for status)"
                color = GREEN if barrel_file_created_successfully else YELLOW
                print(f"{color}Barrel file '{MAGENTA}{barrel_file_path_actual}{RESET}' {status_msg}.{RESET}")
            print(f"{GREEN}{modified_count} .tsx file(s) modified.{RESET}")

            if modified_count > 0 or (barrel_management_attempted and barrel_file_created_successfully):
                revert_cmd_parts = [f"python3 {Path(__file__).name}", "--revert"]
                if args.root: revert_cmd_parts.append(f"--root \"{args.root}\"") # args is global from main
                if target_arg: revert_cmd_parts.append(f"--target \"{target_arg}\"")
                # Add --ui-alias if it was non-default, for user's info, though revert doesn't use it
                if current_ui_alias != DEFAULT_UI_IMPORT_ALIAS: # Check against initial default
                    revert_cmd_parts.append(f"(original --ui-alias was \"{current_ui_alias}\")")

                print(f"{CYAN}To revert changes, run: {MAGENTA}{' '.join(revert_cmd_parts)}{RESET}")

args = None # To be populated by main()

def main():
    global DEFAULT_UI_IMPORT_ALIAS, args # args needs to be global for process_files summary

    script_name = Path(__file__).name
    parser = argparse.ArgumentParser(
        description=f"""Organize import statements in TypeScript/React Next.js projects.
This script helps consolidate imports for UI components located in
'{UI_COMPONENTS_REL_PATH}' into a single barrel file import (default alias: '{DEFAULT_UI_IMPORT_ALIAS}').
Consolidation of UI imports only occurs if a file has more than one import
from the specific UI component structure (e.g., '.../{UI_COMPONENTS_REL_PATH.name}/...').""",
        epilog=f"""Examples:
  Dry run for the whole project:
    python3 {script_name} --dry-run

  Apply changes to a specific feature directory:
    python3 {script_name} --target src/features/myFeature

  Revert changes in the whole project:
    python3 {script_name} --revert

  Use a custom alias for UI imports (ensure tsconfig.json is updated accordingly):
    python3 {script_name} --ui-alias @my-ui-lib

Important:
  - Backups: Original files are backed up with a '.bak' extension before modification (unless it's a dry run).
  - tsconfig.json: For the new import alias (e.g., '{DEFAULT_UI_IMPORT_ALIAS}') to work, ensure you have a corresponding path alias in your tsconfig.json.
    Example for alias '{DEFAULT_UI_IMPORT_ALIAS}': "paths": {{ "{DEFAULT_UI_IMPORT_ALIAS}": ["{(project_root/UI_COMPONENTS_REL_PATH).as_posix()}/index.ts"] }} (replace 'project_root')
  - Verbosity: The script is verbose by default, printing actions as it performs them.
  - Target UI folder name: The script specifically looks for an import path segment matching the last part of UI_COMPONENTS_REL_PATH (i.e., '{UI_COMPONENTS_REL_PATH.name}').
""",
        formatter_class=argparse.RawTextHelpFormatter
    )
    parser.add_argument("--dry-run", action="store_true", help="Perform a dry run to preview changes without modifying any files.")
    parser.add_argument("--revert", action="store_true", help="Revert any changes made by a previous run (restores from .bak files).")
    parser.add_argument("--target", type=str, help="Specify a file or directory to process. Processes the whole project relative to project root if not set.")
    parser.add_argument("--root", type=str, help="Specify the project root directory manually if auto-detection fails.")
    parser.add_argument(
        "--ui-alias",
        type=str,
        default=DEFAULT_UI_IMPORT_ALIAS,
        help=f"The import alias to use for the UI barrel file (default: '%(default)s'). Ensure this alias is configured in your tsconfig.json paths."
    )

    args = parser.parse_args() # Populate global args

    project_root_path = None
    if args.root:
        project_root_path = Path(args.root).resolve()
        if not project_root_path.is_dir():
            print(f"{RED}Error: Provided project root '{args.root}' is not a valid directory.{RESET}")
            return
        print(f"{GREEN}Using manually specified project root: {MAGENTA}{project_root_path}{RESET}")
    else:
        project_root_path = find_project_root()

    if not project_root_path:
        print(f"{RED}Aborting script as project root could not be determined.{RESET}")
        return

    # Update the effective UI import alias based on args
    effective_ui_alias = args.ui_alias
    print(f"{CYAN}Using UI import alias: '{MAGENTA}{effective_ui_alias}{RESET}'")
    # Update the help text example for tsconfig with the actual project root found
    parser.epilog = parser.epilog.replace('(replace \'project_root\')', f'src folder at {project_root_path.as_posix()}')


    process_files(project_root_path, args.target, args.dry_run, args.revert, current_ui_alias=effective_ui_alias)

if __name__ == "__main__":
    main()
